{"version":3,"file":"http.js","sourceRoot":"","sources":["../../src/integrations/http.ts"],"names":[],"mappings":"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","sourcesContent":["import { addBreadcrumb, getCurrentClient } from '@sentry/shim';\nimport { Integration } from '@sentry/types';\nimport { fill } from '@sentry/utils';\nimport { ClientRequest, ClientRequestArgs, ServerResponse } from 'http';\nimport { inherits } from 'util';\n\nlet lastResponse: ServerResponse | undefined;\n\n/**\n * Request interface which can carry around unified url\n * independently of used framework\n */\ninterface SentryRequest extends Request {\n  __ravenBreadcrumbUrl?: string;\n}\n\n/**\n * Function that can combine together a url that'll be used for our breadcrumbs.\n *\n * @param options url that should be returned or an object containing it's parts.\n * @returns constructed url\n */\nfunction createBreadcrumbUrl(options: string | ClientRequestArgs): string {\n  // We could just always reconstruct this from this.agent, this._headers, this.path, etc\n  // but certain other http-instrumenting libraries (like nock, which we use for tests) fail to\n  // maintain the guarantee that after calling origClientRequest, those fields will be populated\n  if (typeof options === 'string') {\n    return options;\n  } else {\n    const protocol = options.protocol || '';\n    const hostname = options.hostname || options.host || '';\n    // Don't log standard :80 (http) and :443 (https) ports to reduce the noise\n    const port =\n      !options.port || options.port === 80 || options.port === 443\n        ? ''\n        : `:${options.port}`;\n    const path = options.path || '/';\n    return `${protocol}//${hostname}${port}${path}`;\n  }\n}\n\n/**\n * Wrapper function for internal _load calls within `require`\n */\nfunction loadWrapper(nativeModule: any): any {\n  // We need to use some functional-style currying to pass values around\n  // as we cannot rely on `bind`, because this has to preserve correct\n  // context for native calls\n  return function(originalLoad: () => any): any {\n    return function(this: SentryRequest, moduleId: string): any {\n      const originalModule = originalLoad.apply(nativeModule, arguments);\n\n      if (moduleId !== 'http') {\n        return originalModule;\n      }\n\n      const origClientRequest = originalModule.ClientRequest;\n      const clientRequest = function(\n        this: SentryRequest,\n        options: ClientRequestArgs | string,\n        callback: () => void,\n      ): any {\n        // Note: this won't capture a breadcrumb if a response never comes\n        // It would be useful to know if that was the case, though, so\n        // todo: revisit to see if we can capture sth indicating response never came\n        // possibility: capture one breadcrumb for \"req sent\" and one for \"res recvd\"\n        // seems excessive but solves the problem and *is* strictly more information\n        // could be useful for weird response sequencing bug scenarios\n\n        origClientRequest.call(this, options, callback);\n        this.__ravenBreadcrumbUrl = createBreadcrumbUrl(options);\n      };\n\n      inherits(clientRequest, origClientRequest);\n\n      fill(clientRequest.prototype, 'emit', emitWrapper);\n\n      fill(originalModule, 'ClientRequest', function(): any {\n        return clientRequest;\n      });\n\n      // http.request orig refs module-internal ClientRequest, not exported one, so\n      // it still points at orig ClientRequest after our monkeypatch; these reimpls\n      // just get that reference updated to use our new ClientRequest\n      fill(originalModule, 'request', function(): any {\n        return function(options: ClientRequestArgs, callback: () => void): any {\n          return new originalModule.ClientRequest(\n            options,\n            callback,\n          ) as ClientRequest;\n        };\n      });\n\n      fill(originalModule, 'get', function(): any {\n        return function(options: ClientRequestArgs, callback: () => void): any {\n          const req = originalModule.request(options, callback);\n          req.end();\n          return req;\n        };\n      });\n\n      return originalModule;\n    };\n  };\n}\n\n/**\n * Wrapper function for request's `emit` calls\n */\nfunction emitWrapper(\n  origEmit: EventListener,\n): (event: string, response: ServerResponse) => EventListener {\n  return function(\n    this: SentryRequest,\n    event: string,\n    response: ServerResponse,\n  ): any {\n    // I'm not sure why but Node.js (at least in v8.X)\n    // is emitting all events twice :|\n    if (lastResponse === undefined || lastResponse !== response) {\n      lastResponse = response;\n    } else {\n      return origEmit.apply(this, arguments);\n    }\n\n    const DSN = getCurrentClient().getDSN();\n\n    const isInterestingEvent = event === 'response' || event === 'error';\n    const isNotSentryRequest =\n      DSN &&\n      this.__ravenBreadcrumbUrl &&\n      !this.__ravenBreadcrumbUrl.includes(DSN.host);\n\n    if (isInterestingEvent && isNotSentryRequest) {\n      addBreadcrumb({\n        category: 'http',\n        data: {\n          method: this.method,\n          status_code: response.statusCode,\n\n          url: this.__ravenBreadcrumbUrl,\n        },\n        type: 'http',\n      });\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\n/** http module integration */\nexport class Http implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public name: string = 'Console';\n  /**\n   * @inheritDoc\n   */\n  public install(): void {\n    const nativeModule = require('module');\n    fill(nativeModule, '_load', loadWrapper(nativeModule));\n    // observation: when the https module does its own require('http'), it *does not* hit our hooked require to instrument http on the fly\n    // but if we've previously instrumented http, https *does* get our already-instrumented version\n    // this is because raven's transports are required before this instrumentation takes place, which loads https (and http)\n    // so module cache will have uninstrumented http; proactively loading it here ensures instrumented version is in module cache\n    // alternatively we could refactor to load our transports later, but this is easier and doesn't have much drawback\n    require('http');\n  }\n}\n"]}